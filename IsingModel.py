import numpy as np
import matplotlib.pyplot as plt
import random
from tqdm import tqdm  # ðŸ”„ Import tqdm


def MetropolisAlgorithm(number_of_repetitions, size, beta):
    '''
    The Metropolis-Hastings model does the following steps

    1: Generate some initial spin configuration and find its energy, E_0. 
    
    2: Pick a random spin in this configuration and flip it
        2a: Calculate the energy of this trial state, E_t

    3: Calculate the difference in energy generated by this spin flip and its probability
        3a: dE = E_t-E_0
        3b: p(dE) = exp(-beta *dE)

    4: Decide whether or not to accept the transition by the following criterion
        4a: If dE<=0 then accept it, since it is energetically favorable. That is, if dE <= 0 then keep the trial state is the new state
        4b: If dE>0 then compare p(dE) to a random number r between 0 and 1. If r <= p then accept the transition

    5: Update the energy, magnetization, etc.
    '''

    #Storage variables
    net_spins = np.zeros(number_of_repetitions)
    net_energy = np.zeros(number_of_repetitions)
    energy = 0

    # Initialize spin configuration
    init_grid = np.random.random((size, size))
    spins = np.zeros((size, size))
    spins[init_grid >= 0.5] = 1
    spins[init_grid < 0.5] = -1


    for q in tqdm(range(number_of_repetitions), desc="Running Metropolis"):

            # Step 1: Compute initial energy
        E_0 = 0
        for h in range(size):
            for k in range(size):
                E_0 += spins[h, k] * (
                    spins[(h - 1) % size, k]
                    + spins[(h + 1) % size, k]
                    + spins[h, (k + 1) % size]
                    + spins[h, (k - 1) % size]
                )

        #Step 2: Pick a random spin and flip it
        i = np.random.randint(0, size)
        j = np.random.randint(0, size)

        spins[i, j] = -spins[i, j]

        #Find the energy of this flipped configuration
        E_t = 0
        for h in range(size):
            for k in range(size):
                E_t += spins[h, k] * (
                    spins[(h - 1) % size, k]
                    + spins[(h + 1) % size, k]
                    + spins[h, (k + 1) % size]
                    + spins[h, (k - 1) % size]
                )

        #Step 3: Calculate the energy difference and the probability of seeing this transition
        dE = E_t - E_0
        p_dE = np.exp(-beta * dE)

        #Step4: Rejection criteria
        if dE > 0:
            r = np.random.uniform(0, 1)
            if r > p_dE:
                spins[i, j] = -spins[i, j]

        energy+=dE

        net_spins[q] = spins.sum()
        net_energy[q] = energy

    return net_spins


# Run and plot
#betas = np.linspace(0.1,1,10)
betas = np.array([0.1,0.5])
spins = np.zeros((len(betas),10000))

for i,beta in enumerate(betas):
    print(i)
    spins[i,:] = MetropolisAlgorithm(10000,50,beta)

for i in range(len(betas)):
    plt.plot(spins[i,:]/50**2,label = f"beta = {betas[i]}")

#plt.plot(spins / (50**2),label = "Average Spins")
plt.xlabel("Number of algorithm steps")
plt.ylabel("Average Spin")
plt.title("Ising Model Evolution")
plt.legend()
plt.grid()
plt.show()
